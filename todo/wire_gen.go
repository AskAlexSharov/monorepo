// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	mgo "github.com/globalsign/mgo"
	requestlog "github.com/google/go-cloud/requestlog"
	runtimevar "github.com/google/go-cloud/runtimevar"
	filevar "github.com/google/go-cloud/runtimevar/filevar"
	server "github.com/google/go-cloud/server"
	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
	grpc_logrus "github.com/grpc-ecosystem/go-grpc-middleware/logging/logrus"
	grpc_recovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
	grpc_ctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
	grpc_prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
	errors "github.com/pkg/errors"
	logrus "github.com/sirupsen/logrus"
	cli "github.com/urfave/cli"
	trace "go.opencensus.io/trace"
	grpc "google.golang.org/grpc"
	time "time"
)

// Injectors from inject_local.go:

func setupLocal(ctx *cli.Context) (*application, func(), error) {
	logger := _wireLoggerValue
	session, err := localDb(ctx)
	if err != nil {
		return nil, nil, err
	}
	v, cleanup := appHealthChecks(session)
	exporter := _wireExporterValue
	sampler := trace.AlwaysSample()
	options := &server.Options{
		RequestLogger:         logger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
	}
	server2 := server.New(options)
	entry := localLogrus(ctx)
	server3 := localGrpc(ctx, entry)
	variable, cleanup2, err := localRuntimeVar(ctx)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	application2 := newApplication(server2, session, entry, server3, variable)
	return application2, func() {
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireLoggerValue   = requestlog.Logger(nil)
	_wireExporterValue = trace.Exporter(nil)
)

// inject_local.go:

func localDb(ctx *cli.Context) (*mgo.Session, error) {
	addr := mongoAddr(ctx)
	sess, err := mgo.Dial(addr)
	if err != nil {
		return nil, errors.New("Can't connect to Mongo on address: " + addr + ", by reason: " + err.Error())
	}
	return sess, nil
}

func localLogrus(ctx *cli.Context) *logrus.Entry {
	logger := logrus.NewEntry(logrus.New())
	grpc_logrus.ReplaceGrpcLogger(logger)
	logrus.SetLevel(logrus.DebugLevel)

	return logger
}

func localGrpc(ctx *cli.Context, logger *logrus.Entry) *grpc.Server {
	return grpc.NewServer(grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(grpc_ctxtags.StreamServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)), grpc_prometheus.StreamServerInterceptor, grpc_logrus.StreamServerInterceptor(logger), grpc_recovery.StreamServerInterceptor(grpc_recovery.WithRecoveryHandler(panicHandler)))), grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(grpc_ctxtags.UnaryServerInterceptor(grpc_ctxtags.WithFieldExtractor(grpc_ctxtags.CodeGenRequestFieldExtractor)), grpc_prometheus.UnaryServerInterceptor, grpc_logrus.UnaryServerInterceptor(logger), grpc_recovery.UnaryServerInterceptor(grpc_recovery.WithRecoveryHandler(panicHandler)))))
}

func localRuntimeVar(ctx *cli.Context) (*runtimevar.Variable, func(), error) {
	v, err := filevar.NewVariable("message_of_the_day", runtimevar.StringDecoder, &filevar.WatchOptions{
		WaitTime: time.Minute,
	})
	if err != nil {
		return nil, nil, err
	}
	return v, func() { v.Close() }, nil
}
